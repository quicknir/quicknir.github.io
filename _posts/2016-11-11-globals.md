---
layout: post
title: What Every *nix C++ dev should know about globals
author: Nir Friedman and Sandeep Kumar Gupta
---

Doing a global correctly in C++ is not a trivial thing, when the global itself
is non-trivial. Or, put another way: globals that have constructors and
destructors can easily make a big mess. There are surprisingly few resources
summarizing exactly what considerations are relevant in order to make sure
globals behave themselves. There are some well known cases, like [static initialization order fiasco][siof]
. Maybe this is because to really talk about globals, we have to talk about the linker, and the linker is a strange beast.
Without it, you can't write any real C++ program, but it's not covered by the
standard, its behavior is relatively rarely discussed, and varies from platform
to platform.

## A motivating example

Consider the following example code; comments with `<>` inside are used to
indicate a filename:

{% highlight cpp linenos %}
// <static.h>
#pragma once

#include <string>

extern std::string g_str;

// <static.cpp>
#include "static.h"

std::string g_str = "hello for a really really";

// <dynamic.h>
#pragma once

#include "static.h"

#include <string>

std::string globalGetter();

// <dynamic.cpp>
#include "dynamic.h"
#include "static.h"

std::string globalGetter() {
    return g_str;
}

// <main.x.cpp>
#include "static.h"
#include "dynamic.h"

#include <iostream>

int main() {
    std::cerr << g_str << "\n";
    std::cerr << globalGetter() << "\n";
    return 0;
}
{% endhighlight %}

As you might guess, this code represents a static library, a shared (or dynamic,
I will use the terms interchangeably) library, and a main executable. There's a
global object in the static library, used in the shared library and in the
executable.

There are three translation units (TUs) here, one for each file ending in
`.cpp`. As far as a compiler is concerned, all of these translation units are
kosher. Let's try to link this together and see what happens:

==> Not sure how this looks in final page, but they look pretty bad in markdown page in browser. How about making
==> this as they appear in terminal?

{% highlight bash linenos %}
# Compile static translation unit
clang++ -std=c++14 -c -fpic static.cpp
# Produce a static library
ar rcs libstatic.a static.o
# Compile dynamic translation unit
clang++ -std=c++14 -c -fpic dynamic.cpp
# Produce dynamic library, linking against static
clang++ -shared -o libdynamic.so dynamic.o -L./ -lstatic
# Compile main executable translation unit
clang++ -std=c++14 -c main.x.cpp
# Link executable against shared and static libraries
clang++ -L./ -Wl,-rpath=./ main.x.o -lstatic -ldynamic
{% endhighlight %}

I'll get into more details later, for me, running the resulting executable
results in a segfault. If you ever use globals and are surprised at this
segfaulting, read on. And by the way: class static variables are just scoped
global variables; and are susceptible to all the same problems.

## What this post is not

Before I continue, there's a few caveats about this post.

The first is that this post is not designed to teach you about the linker for
its own sake. If you want to learn more about the linker, then by all means
there are good posts out [there](eli bendersky link). Most developers are not
experts on the linker but have working knowledge that lets them do what they
need to do. That's the goal here: to understand enough to use globals safely.

Second, this article is not in any way an endorsement of using globals, as a
general technique. Quite the opposite: these issues should only highlight how
tricky globals really are. There are some problems though where globals make a
good case for themselves: for logging frameworks, for intrusive performance
profiling, for registration to facilitate dynamic object construction, and so
on. Some may still be against globals in these contexts, but hopefully
reasonable people can agree to disagree.

## Keep calm and follow along

You can clone a repo that has the source code necessaary to reproduce these
issues [here](github link). The first example that causes a segfault is in a
directory called `minimal`; you can build it by `cd`ing into that directory and
running `../build.sh`.

## Global informants

To try to understand what's going on, the first thing we need is more
information. Segfaults suggest that is being destroyed incorrectly, but we know
that a standard library class like `string` will not have bugs of this
magnitude. We can clearly see potential for multiple strings to be constructed,
so let's see where each global is being consructed and destructed. We replace
our global `string` class with a class that I use (with variants) often:

{% highlight cpp linenos %}
struct Informer {
  Informer() {
    std::cerr << "ctor " << this << "\n";
  }
  Informer *get() { return this; }

  ~Informer() {
    std::cerr << "dtor " << this << "\n";
  }
};
{% endhighlight %}

You can build this example in the `informer` sub-directory. Building and
running, we see:

```
ctor 0x602193
ctor 0x602193
0x602193
0x602193
dtor 0x602193
dtor 0x602193
```

This is pretty crazy stuff. That means that our constructor is run twice at the
exact same place in memory, and then the same with our destructors. The second
constructor call will perform a second heap allocation and then overwrite the
pointer that the `string` contains, which means that memory will be lost
forever. It's not immediately clear whether the second destructor will free
memory at the same location twice, or at a complete garbage location,
but it's definitely not happening anywhere good. Can we try to understand why
this is happening?

## Linker 100 (`--Linker 101`)

To understand the linker, you need to understand symbols. Classes, functions,
and global variables are all symbols. To see the symbols in any piece of object
code (object file, static or dynamic library), we can use the command `objdump`.
For instance, we can run the following command on `main.x.o`

{% highlight bash linenos %}
~/D/g/informer ❯❯❯ nm --demangle main.x.o

                 U __cxa_atexit
0000000000000000 t __cxx_global_var_init
                 U __dso_handle
                 U g_informer
0000000000000050 t _GLOBAL__sub_I_main.x.cpp
0000000000000000 T main
                 U globalGetter()
0000000000000000 W Informer::get()
                 U std::ostream::operator<<(void const*)
                 U std::ios_base::Init::Init()
                 U std::ios_base::Init::~Init()
                 U std::cerr
0000000000000000 b std::__ioinit
                 U std::basic_ostream<char, ... (cut off by me)
{% endhighlight %}

You can see a whole bunch of things here that look familiar. The junk in and
amongst the familiar stuff is a result of name mangling, which we won't get into
here. The main thing to take away from this right now is that a "U" means that
the symbol is *undefined* in the current translation unit. That is, it's
declared, and probably used, but the definition must be elsewhere.

So how does the linker put stuff together? Well, it's fairly straightforward.
Its arguments in this case are `.o` files, and static and dynamic libraries. The
linker will:

 1. Begin by creating an empty list of symbols.
 2. It iterates over the arguments in the order given, i.e. from left to right.
 3. For each argument, it firsts adds all of the undefined symbols to the list
    of symbols (noting that they are undefined).
 4. It then looks at its list of undefined symbols, and sees if any of those
    symbols are defined in the current argument.
 5. When it encounters symbols like that, what it does next depends on the type
    of the argument:
    1. If the argument is a `.o` file or a static library, it essentially copies
    and pastes the object code into the target it is linking.
    2. If the argument is a dynamic library, it notes that the symbol(s) are
    defined in such-and-such shared library; it is now the job of the dynamic
    loader to load up the shared library at program start so that the symbols'
    definitions can be used.

This in turn, has a few interesting implications for us. First, note that the
dynamic library itself was created by linking against our static library, which
had the needed definition for `g_informer`. Because static linking will paste
the definition into the target, that means our dynamic library has its own
definition for `g_informer`.

Next, having established that both the static and dynamic library define
`g_informer` (which you can verify with `nm`), the algorithm above implies that
there is an ordering dependency: the linker will pick up the symbol from
whichever library it sees first. So we run the following experiment:

{% highlight bash linenos %}
~/D/g/informer ❯❯❯ clang++ -L./ -Wl,-rpath=./ main.x.o -ldynamic -lstatic
~/D/g/informer ❯❯❯ ./a.out

ctor 0x601170
0x601170
0x601170
dtor 0x601170
{% endhighlight %}

Wow, everything is fixed! Why? Well,


{% highlight bash linenos %}
objdump -CS a.out > foo.txt
{% endhighlight %}

{% highlight bash linenos %}
0000000000400a90 <__cxx_global_var_init.1>:
  ...
  400a98:	48 8d 3d f4 16 20 00 	lea    0x2016f4(%rip),%rdi        # 602193 <g_informer>
  400a9f:	e8 cc 01 00 00       	callq  400c70 <Informer::Informer()>
  400aa4:	48 8d 3d 15 02 00 00 	lea    0x215(%rip),%rdi        # 400cc0 <Informer::~Informer()>
  400aab:	48 8d 35 e1 16 20 00 	lea    0x2016e1(%rip),%rsi        # 602193 <g_informer>
  400ab2:	48 8d 15 af 15 20 00 	lea    0x2015af(%rip),%rdx        # 602068 <__dso_handle>
  400ab9:	e8 b2 fe ff ff       	callq  400970 <__cxa_atexit@plt>
  ...

0000000000400ad0 <_GLOBAL__sub_I_static.cpp>:
  ...
  400ad9:	e8 b2 ff ff ff       	callq  400a90 <__cxx_global_var_init.1>
  ...
{% endhighlight %}

{% highlight bash linenos %}
objdump -CS libdynamic.so > foo.txt
{% endhighlight %}

{% highlight bash linenos %}
0000000000000ab0 <__cxx_global_var_init.1>:
 ...
 abf:	e8 3c ff ff ff       	callq  a00 <Informer::Informer()@plt>
 ac4:	48 8b 3d 2d 15 20 00 	mov    0x20152d(%rip),%rdi        # 201ff8 <_DYNAMIC+0x230>
 acb:	48 8b 35 fe 14 20 00 	mov    0x2014fe(%rip),%rsi        # 201fd0 <_DYNAMIC+0x208>
 ad2:	48 8d 15 7f 15 20 00 	lea    0x20157f(%rip),%rdx        # 202058 <__dso_handle>
 ad9:	e8 c2 fe ff ff       	callq  9a0 <__cxa_atexit@plt>
 ...
{% endhighlight %}

Key point: assembly analysis shows that with static linked first, executable
initializes global, otherwise it doesn't. Shared library will initialize it
either way. Because the symbol of the global itself is already defined before
either initialization occurs, the initialization occurs on the same symbol.

[[siof]]: https://isocpp.org/wiki/faq/ctors#static-init-order


[Comment to be removed]
* I found this article http://www.lurklurk.org/linkers/linkers.html while searching for whether c++ standard talks about linking or not. Not sure how useful it is.
* Do you think it makes sense to run main.x.cpp under address sanitizer to see how it performs?
* The other thing that I noticed is usage of both "we need to understand" and "you need to understand". The latter seems pedantic, so prefer first?
* To see all the symbols in an executable I find this command handy: `readelf -s main.x.o | c++filt`. It lists undefined symbols as UND
