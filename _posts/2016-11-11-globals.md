---
layout: post
title: What every C++ dev should know about globals
author: Nir Friedman
---

Doing a global correctly in C++ is not a trivial thing, when the global itself
is non-trivial. Or, put another way: globals that have constructors and
destructors can easily make a big mess. There's surprisingly few resources
summarizing exactly what considerations are relevant in order to make sure
globals behave themselves. There are some well known cases, like static
initialization order fiasco (SIOF). Maybe this is because to really talk about
globals, we have to talk about the linker, and the linker is a strange beast.
Without it, you can't write any real C++ program, but it's not always as clearly
covered by the standard, its behavior is relatively rarely discussed, and varies
from platform to platform.

## A motivating example

Consider the following example code; comments with `<>` inside are used to
indicate a filename:

<pre class="code_subtitle">
static.h
</pre>
{% highlight cpp linenos %}
#pragma once

#include <string>

extern std::string g_str;
{% endhighlight %}

<pre class="code_subtitle">
static.cpp
</pre>
{% highlight cpp linenos %}
#include "static.h"

std::string g_str = "string too long for short string optimization";

{% endhighlight %}

<pre class="code_subtitle">
dynamic.h
</pre>
{% highlight cpp linenos %}
#pragma once

#include "static.h"

#include <string>

std::string& globalGetter();
{% endhighlight %}

<pre class="code_subtitle">
dynamic.cpp
</pre>
{% highlight cpp linenos %}
#include "dynamic.h"
#include "static.h"

std::string& globalGetter() {
    return g_str;
}
{% endhighlight %}

<pre class="code_subtitle">
main.x.cpp
</pre>
{% highlight cpp linenos %}
#include "static.h"
#include "dynamic.h"

#include <iostream>

int main() {
    std::cerr << g_str << "\n";
    std::cerr << globalGetter() << "\n";
    return 0;
}
{% endhighlight %}

As you might guess, this code represents a static library, a shared (or dynamic,
I will use the terms interchangeably) library, and a main executable. There's a
global object in the static library, used in the shared library and in the
executable.

There are three translation units (TUs) here, one for each file ending in
`.cpp`. As far as a compiler is concerned, all of these translation units are
kosher. Let's try to link this together and see what happens:

{% highlight bash linenos %}
# Compile static translation unit
clang++ -std=c++14 -c -fpic static.cpp
# Produce a static library
ar rcs libstatic.a static.o
# Compile dynamic translation unit
clang++ -std=c++14 -c -fpic dynamic.cpp
# Produce dynamic library, linking against static
clang++ -shared -o libdynamic.so dynamic.o -L./ -lstatic
# Compile main executable translation unit
clang++ -std=c++14 -c main.x.cpp
# Link executable against shared and static libraries
clang++ -L./ -Wl,-rpath=./ main.x.o -lstatic -ldynamic
{% endhighlight %}

For me, running the resulting executable results in a segfault. If you ever use
globals and are surprised at this segfaulting, read on. And by the way: class
static variables are just scoped global variables; and are susceptible to all
the same problems.

## What this post is not

Before I continue, there's a few caveats about this post.

The first is that this post is not designed to teach you about the linker for
its own sake. If you want to learn more about the linker, then by all means
there are good posts out [there](eli bendersky link). Most developers are not
experts on the linker but have working knowledge that lets them do what they
need to do. That's the goal here: to understand enough to use globals safely.

Second, this article is not in any way an endorsement of using globals, as a
general technique. Quite the opposite: these issues should only highlight how
tricky globals really are. There are some problems though where globals make a
good case for themselves: for logging frameworks, for intrusive performance
profiling, for registration to facilitate dynamic object construction, and so
on. Some may still be against globals in these contexts, but hopefully
reasonable people can agree to disagree.

## Keep calm and follow along

You can clone a repo that has the source code necessaary to reproduce these
issues [here](github link). The first example that causes a segfault is in a
directory called `minimal`; you can build it by `cd`ing into that directory and
running `../build.sh`.

## Global informants

To try to understand what's going on, the first thing we need is more
information. Segfaults suggest that it is being destroyed incorrectly, but we
know that a standard library class like `string` will not have bugs of this
magnitude. We can clearly see potential for multiple strings to be constructed,
so let's see where each global is being consructed and destructed. We replace
our global `string` class with a class that I use (with variants) often:

{% highlight cpp linenos %}
struct Informer {
  Informer() {
    std::cerr << "ctor " << this << "\n";
  }
  Informer* get() { return this; }

  ~Informer() {
    std::cerr << "dtor " << this << "\n";
  }
};
{% endhighlight %}

You can build this example in the `informer` sub-directory. Instead of printing
the object itself in `main`, we instead print the address. Building and running,
we see:

```
ctor 0x602193
ctor 0x602193
0x602193
0x602193
dtor 0x602193
dtor 0x602193
```

This is pretty crazy stuff. That means that our constructor is run twice at the
exact same place in memory, and then the same with our destructors. The second
constructor call will perform a second heap allocation and then overwrite the
pointer that the `string` contains, which means that memory will be lost forever
(in fact, running the first example under valgrind will show 46 bytes definitely
lost; which is the length of the string plus one byte for the null terminator).
It's not immediately clear whether the second destructor will free memory at the
same location twice, or at a complete garbage location, but it's definitely not
happening anywhere good. Can we try to understand why this is happening?

## Linker 100 (`--Linker_101`)

To understand the linker, you need to understand symbols. Classes, functions,
and global variables are all symbols. To see the symbols in any piece of object
code (object file, static or dynamic library), we can use the command `nm`.
For instance, we can run the following command on `main.x.o`

{% highlight bash linenos %}
~/D/g/informer ❯❯❯ nm --demangle main.x.o

                 U __cxa_atexit
0000000000000000 t __cxx_global_var_init
                 U __dso_handle
                 U g_informer
0000000000000050 t _GLOBAL__sub_I_main.x.cpp
0000000000000000 T main
                 U globalGetter()
0000000000000000 W Informer::get()
                 U std::ostream::operator<<(void const*)
                 U std::ios_base::Init::Init()
                 U std::ios_base::Init::~Init()
                 U std::cerr
0000000000000000 b std::__ioinit
                 U std::basic_ostream<char, ... (cut off by me)
{% endhighlight %}

You can see a whole bunch of things here that look familiar. The junk in and
amongst the familiar stuff is a result of name mangling, which we won't get into
here. The main thing to take away from this right now is that a "U" means that
the symbol is *undefined* in the current translation unit. That is, it's
declared, and probably used, but the definition must be elsewhere.

So how does the linker put stuff together? Well, it's fairly straightforward.
Its arguments in this case are `.o` files, and static and dynamic libraries. The
linker will:

 1. Begin by creating an empty list of symbols.
 2. It iterates over the arguments in the order given, i.e. from left to right.
 3. For each argument, it firsts adds all of the undefined symbols to the list
    of symbols (noting that they are undefined).
 4. It then looks at its list of undefined symbols, and sees if any of those
    symbols are defined in the current argument.
 5. When it encounters symbols like that, what it does next depends on the type
    of the argument:
    1. If the argument is a `.o` file or a static library, it essentially copies
    and pastes the object code into the target it is linking.
    2. If the argument is a dynamic library, it notes that the symbol(s) are
    defined in such-and-such shared library; it is now the job of the dynamic
    loader to load up the shared library at program start so that the symbols'
    definitions can be used.

This in turn, has a few interesting implications for us. First, note that the
dynamic library itself was created by linking against our static library, which
had the needed definition for `g_informer`. Because static linking will paste
the definition into the target, that means our dynamic library has its own
object code for `g_informer`.

Next, having established that both the static and dynamic library define
`g_informer` (which you can verify with `nm`), the algorithm above implies that
there is an ordering dependency: the linker will pick up the symbol from
whichever library it sees first. So we run the following experiment:

{% highlight bash linenos %}
~/D/g/informer ❯❯❯ clang++ -L./ -Wl,-rpath=./ main.x.o -ldynamic -lstatic
~/D/g/informer ❯❯❯ ./a.out

ctor 0x601170
0x601170
0x601170
dtor 0x601170
{% endhighlight %}

Wow, everything is fixed! Why? Well, to understand what's happening, we'll have
to dig a little bit deeper. We will use `objdump -CS` to actually examine the
assembly to see what is being run. First, let's look at the case where the
static library is linked first and we have the problem:

{% highlight bash linenos %}
~/D/g/informer ❯❯❯ clang++ -L./ -Wl,-rpath=./ main.x.o -lstatic -ldynamic
~/D/g/informer ❯❯❯ objdump -CS | egrep -C 5 "callq.*Informer\(\)"
0000000000400a90 <__cxx_global_var_init.1>:
  400a90:	55                   	push   %rbp
  400a91:	48 89 e5             	mov    %rsp,%rbp
  400a94:	48 83 ec 10          	sub    $0x10,%rsp
  400a98:	48 8d 3d f4 16 20 00 	lea    0x2016f4(%rip),%rdi
                                                   # 602193 <g_informer>
  400a9f:	e8 cc 01 00 00       	callq  400c70 <Informer::Informer()>
  400aa4:	48 8d 3d 15 02 00 00 	lea    0x215(%rip),%rdi
                                                   # 400cc0 <Informer::~Informer()>
  400aab:	48 8d 35 e1 16 20 00 	lea    0x2016e1(%rip),%rsi
                                                   # 602193 <g_informer>
  400ab2:	48 8d 15 af 15 20 00 	lea    0x2015af(%rip),%rdx
                                                   # 602068 <__dso_handle>
  400ab9:	e8 b2 fe ff ff       	callq  400970 <__cxa_atexit@plt>
  400abe:	89 45 fc             	mov    %eax,-0x4(%rbp)
{% endhighlight %}

This is interesting for two reasons. First, we can observe that the constructor
is being called in a section with "global_var_init" in the name. Fairly
suggestive. Second, we can see that along with the global being initialized
here, the destructor of `Informer` is registered to run on `g_informer` at exit.
This is the mechanism by which destruction of globals is handled.

What if we swap `-lstatic` and `-ldynamic` on the line above? Well, you won't
get any result. So no global is initialized in any object code found in the
binary. So, where is it? Well, obviously, in the shared library:

{% highlight bash linenos %}
~/D/g/informer ❯❯❯ objdump -CS libdynamic.so | grep -P -A 10 '^((?!callq).)*global_var_init.1'
0000000000000ab0 <__cxx_global_var_init.1>:
 ab0:	55                   	push   %rbp
 ab1:	48 89 e5             	mov    %rsp,%rbp
 ab4:	48 83 ec 10          	sub    $0x10,%rsp
 ab8:	48 8b 3d 11 15 20 00 	mov    0x201511(%rip),%rdi
                                               # 201fd0 <_DYNAMIC+0x208>
 abf:	e8 3c ff ff ff       	callq  a00 <Informer::Informer()@plt>
 ac4:	48 8b 3d 2d 15 20 00 	mov    0x20152d(%rip),%rdi
                                               # 201ff8 <_DYNAMIC+0x230>
 acb:	48 8b 35 fe 14 20 00 	mov    0x2014fe(%rip),%rsi
                                               # 201fd0 <_DYNAMIC+0x208>
 ad2:	48 8d 15 7f 15 20 00 	lea    0x20157f(%rip),%rdx
                                               # 202058 <__dso_handle>
 ad9:	e8 c2 fe ff ff       	callq  9a0 <__cxa_atexit@plt>
 ade:	89 45 fc             	mov    %eax,-0x4(%rbp)
{% endhighlight %}

So the global gets initialized and registered for destruction in the shared
library, regardless. When `-lstatic` is encountered on the final executable's
link line first, the executable gets the global from the static library, so the
object code is copy and pasted in. But the shared library already has a copy of
the global that gets initialized the instant that it is loaded. So we double up.
If we reverse the link order, then the executable is instructed to get the
global from the shared library and not have its own, and all is well.

## A solution

Okay, so all these details are interesting and perhaps surprising, but really
what we want is to avoid delving into these details and just write stuff that
works. So let's introduce a first technique that solves all these issues: The
Meyers Singleton. Or rather, a better name in this context would be a Meyers
Global:

{% highlight cpp linenos %}
// <static.h>
#pragma once

#include <string>

std::string& g_str();

// <static.cpp>
#include "static.h"

std::string& g_str () {
    static std::string s("hello for a really really");
    return s;
}
{% endhighlight %}

The idea here is simple: instead of having a global, we simply have a function
that we call that returns a reference to a static local. Instead of using a
global directly, you simply call the function wherever you would have used the
global.

As far as this solution goes, it is fine, and when I first learned about all the
pitfalls I used it quite often (and still sometimes do). A common use case was
when I wanted to encode some kind of constant associative map for a class, to
use in some of its functions; a function with a static local `unordered_map`
returning it by reference was a good solution.

That said, there are two issues with this solution

The first issue is simply that it's lazy. While this can be nice in specific
cases, usually this is a disadvantage. If you know you are going to initialize a
global at some point, usually you'd rather do it at program start where there's
the best chance of cycles being cheap. It can be rather odd when looking at
performance to see a cheap function have a single massive spike because your
entire logging framework got initialized on the first call. Also, if your
initialization is going to fail, better it fail as early as possible.

The second issue is that it's a performance hit. Static local variables get
initialized the first time control passes through them; there's no magic way
around using a boolean for this. This is even required to be thread safe. Most
implementations are smart enough to first test a normal boolean before doing any
atomic operations, but still. The main cost is basically a branch every time you
access the global, and a secondary cost is some unnecessary code getting in the
way (though again, good implementations will put all of the already-initialized
branch code at the start of the function).

And if you're easily annoyed, you can also also count having to type two parens
every single time you want to use your global.

## A better solution
It turns out that a minor modification of the Meyers Singleton solves both of
the issues that we identified with it:

{% highlight cpp linenos %}
// <static.h>
#pragma once

#include <string>

namespace detail {
    std::string& g_str();  // can define in header or cpp
}

static auto& g_str = detail::g_str();
{% endhighlight %}

In this implementation, a function with a static local is still used, but it is
an implementation detail. Instead, we initialize a static reference. There will
be one copy of this reference in every translation unit, but they'll all be
initialized the same way and point to the same thing. This turns out to solve
both of our issues with the Meyers Singleton:

 1. It's no longer lazy, because the reference is a global and has to be
    initialized. You are guaranteed initialization before `main` starts.
 2. The reference is just that: a simple, plain reference. You longer pay for a
    branch every time you use your global.
 3. And, if you count it, you save two parens every time you use your global
    (yay!).

I call this the Nir Global; if Scott Meyers can do it, why not me? Jokes aside,
the technique needs a name
(static-global-reference-initialized-by-a-function-returning-a-reference-to-a-static-local
is just too long). I haven't seen this discussed or suggested anywhere, and when
I asked a related [question](SO link), nobody displayed familiarity with it.
Doubtless people have used it before, but I hope this post helps popularize it.

## Concluding Thoughts

We described some of the issues with the ways that globals are typically done,
issues with certain linker implementations, and arrived at a solution that:

 - works reliably for different linker implementations
 - regardless of combinations of static and dynamic linking
 - works for header only libraries
 - avoids surprises stemming from laziness; always initializes before `main`
 - has good performane characteristics
 - has the same interface (no function call) as globals generally do, so isn't a breaking change

There will be a follow-up article, where we will look at a topic that was not
discussed here: what happens when you have interdependent globals? Surprising
code snippits, useful solutions, and more advantages of the Nir Global over the
Meyers Singleton in the next post.
